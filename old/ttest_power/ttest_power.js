// Generated by CoffeeScript 1.9.1
var bgcolor, colors, curve, draw_plot, figheight, figs, figtoth, figtotw, figwidth, getSliderValue, height, i, isMobile, k, margin, npts, opacity, p, par, param, printSliderValue, short, svg, titles, update_plots, width, xrange, xscale, yrange, yscale;

getSliderValue = function(sliderID) {
  var digits, slider;
  slider = document.getElementById(sliderID);
  if (sliderID === "alpha") {
    digits = Math.floor(-slider.value) + 2;
    return Math.round(Math.pow(10, slider.value) * Math.pow(10, digits)) / Math.pow(10, digits);
  } else {
    return slider.value;
  }
};

printSliderValue = function(sliderID) {
  var textbox, textboxID, val;
  val = getSliderValue(sliderID);
  textboxID = sliderID + "value";
  textbox = document.getElementById(textboxID);
  return textbox.value = val;
};

isMobile = function() {
  return typeof window.orientation !== 'undefined';
};

param = {
  n: {
    text: "sample size per group, <em>n</em>",
    min: 2,
    max: 100,
    step: 1,
    value: 25
  },
  delta: {
    text: "effect, &Delta;",
    min: 0,
    max: 10,
    step: 0.1,
    value: 2
  },
  sigma: {
    text: "population SD, &sigma;",
    min: 0.1,
    max: 10,
    step: 0.1,
    value: 2
  },
  alpha: {
    text: "significance level, &alpha;",
    min: -4,
    max: -0.6,
    step: 0.01,
    value: Math.log10(0.05)
  }
};

for (par in param) {
  p = d3.select("form#sliders").append("p");
  p.append("input").attr("id", par).attr("type", "range").attr("min", param[par].min).attr("max", param[par].max).attr("value", param[par].value).attr("step", param[par].step);
  p.append("a").html(param[par].text + " = ");
  p.append("output").attr("id", par + "value").attr("for", par);
  printSliderValue(par);
}

if (isMobile()) {
  d3.select("form#sliders").on("change", function() {
    var k, len, ref;
    ref = ["n", "alpha", "delta", "sigma"];
    for (k = 0, len = ref.length; k < len; k++) {
      par = ref[k];
      printSliderValue(par);
    }
    return update_plots();
  });
} else {
  d3.select("form#sliders").on("input", function() {
    var k, len, ref;
    ref = ["n", "alpha", "delta", "sigma"];
    for (k = 0, len = ref.length; k < len; k++) {
      par = ref[k];
      printSliderValue(par);
    }
    return update_plots();
  });
}

bgcolor = "#ccc";

colors = ["slateblue", "#d02090"];

npts = 500;

figwidth = 500;

figheight = 250;

opacity = 0.5;

margin = {
  left: 50,
  right: 20,
  bottom: 50,
  top: 30,
  inner: 5
};

figtotw = figwidth + margin.left + margin.right;

figtoth = figheight + margin.top + margin.bottom;

height = figtoth * 3;

width = figtotw;

svg = d3.select("div#chart").append("svg").attr("width", window.innerWidth - 420).attr("height", window.innerHeight - 20);

svg.attr("viewBox", "0,0," + width + "," + height).attr("preserveAspectRatio", "xMinYMin meet");

figs = [null, null, null];

titles = ["Population distributions", "Distributions of sample mean", "Distribution of test statistic"];

short = ["pop", "samp", "stat"];

xscale = [null, null, null];

yscale = [null, null, null];

xrange = [[0, 1], [0, 1], [-4, 8]];

yrange = [[0, 1], [0, 1], [0, dnorm(0, 0, 1)]];

draw_plot = function(index) {
  var ticks;
  figs[index] = svg.append("g").attr("id", short[index]).attr("transform", "translate(0," + (figtoth * index) + ")").append("svg").attr("width", figtotw).attr("height", figtoth);
  figs[index].append("rect").attr("x", margin.left).attr("y", margin.top).attr("height", figheight).attr("width", figwidth).attr("fill", bgcolor).attr("stroke", "black").attr("stroke-width", 1);
  figs[index].append("text").text(titles[index]).attr("x", margin.left + figwidth / 2).attr("y", margin.top / 2).attr("dominant-baseline", "middle").attr("text-anchor", "middle");
  if (index === 0 || index === 1) {
    xrange[index] = [100 - param.sigma.max * 3, 100 + param.delta.max + param.sigma.max * 3];
    yrange[index] = [0, dnorm(0, 0, param.sigma.min)];
  }
  xscale[index] = d3.scale.linear().clamp(true).range([margin.left, margin.left + figwidth]).domain(xrange[index]);
  yscale[index] = d3.scale.linear().clamp(true).range([margin.top + figheight, margin.top + margin.inner]).domain(yrange[index]);
  ticks = xscale[index].ticks(6);
  figs[index].append("g").attr("class", "axis").selectAll("empty").data(ticks).enter().append("line").attr("x1", function(d) {
    return xscale[index](d);
  }).attr("x2", function(d) {
    return xscale[index](d);
  }).attr("y1", margin.top).attr("y2", figheight + margin.top).attr("stroke", "white").attr("stroke-width", 1);
  figs[index].selectAll("empty").data(ticks).enter().append("text").attr("x", function(d) {
    return xscale[index](d);
  }).attr("y", figheight + margin.top + margin.bottom * 0.4).text(function(d) {
    return d;
  }).attr("dominant-baseline", "middle").attr("text-anchor", "middle");
  return figs[index].append("rect").attr("x", margin.left).attr("y", margin.top).attr("height", figheight).attr("width", figwidth).attr("fill", "none").attr("stroke", "black").attr("stroke-width", 1);
};

for (i = k = 0; k <= 2; i = ++k) {
  draw_plot(i);
}

curve = function(index) {
  return d3.svg.line().x(function(d) {
    return xscale[index](d.x);
  }).y(function(d) {
    return yscale[index](d.y);
  });
};

update_plots = function() {
  var alpha, critval, data, delta, df, j, maxaltx, maxalty, mu, n, ncp, power, scale4x, sem, sigma, x, y;
  svg.selectAll(".curves").remove();
  sigma = +getSliderValue("sigma");
  delta = +getSliderValue("delta");
  n = +getSliderValue("n");
  sem = sigma / Math.sqrt(n);
  df = 2 * n - 2;
  alpha = +getSliderValue("alpha");
  ncp = delta / sem / Math.sqrt(2);
  scale4x = d3.scale.linear().domain([0, 1]).range([100 - sigma * 6, 100 + delta + sigma * 6]);
  x = d3.range(npts).map(function(i) {
    return scale4x(i / npts);
  });
  yscale[0].domain([0, dnorm(0, 0, sigma)]);
  yscale[1].domain([0, dnorm(0, 0, sem)]);
  mu = [100, 100 + delta];
  for (i in mu) {
    data = [];
    for (j in x) {
      data.push({
        x: x[j],
        y: dnorm(x[j], mu[i], sigma)
      });
    }
    figs[0].append("path").attr("class", "curves").datum(data).attr("d", curve(0)).attr("fill", "none").attr("stroke", colors[i]).attr("stroke-width", 2);
  }
  scale4x = d3.scale.linear().domain([0, 1]).range([100 - sem * 6, 100 + delta + sem * 6]);
  x = d3.range(npts).map(function(i) {
    return scale4x(i / npts);
  });
  for (i in mu) {
    data = [];
    for (j in x) {
      data.push({
        x: x[j],
        y: dnorm(x[j], mu[i], sem)
      });
    }
    figs[1].append("path").attr("class", "curves").datum(data).attr("d", curve(1)).attr("fill", "none").attr("stroke", colors[i]).attr("stroke-width", 2);
  }
  scale4x = d3.scale.linear().domain([0, 1]).range(xrange[2]);
  x = d3.range(npts).map(function(i) {
    return scale4x(i / npts);
  });
  data = [];
  for (j in x) {
    data.push({
      x: x[j],
      y: dt(x[j], df)
    });
  }
  figs[2].append("path").attr("class", "curves").datum(data).attr("d", curve(2)).attr("fill", "none").attr("stroke", "black").attr("stroke-width", 2);
  critval = qt(1 - alpha / 2, df);
  if (critval < xrange[2][1]) {
    scale4x = d3.scale.linear().domain([0, 1]).range([critval, xrange[2][1]]);
    x = d3.range(npts).map(function(i) {
      return scale4x(i / npts);
    });
    data = [];
    for (j in x) {
      data.push({
        x: x[j],
        y: dt(x[j], df)
      });
    }
    data.push({
      x: xrange[2][1],
      y: 0
    });
    data.push({
      x: critval,
      y: 0
    });
    figs[2].append("path").attr("class", "curves").datum(data).attr("d", curve(2)).attr("fill", colors[0]).attr("stroke", "none").attr("opacity", opacity);
  }
  power = 1 - pnct(critval, df, ncp);
  d3.select("div#power p").text("Power = " + (d3.format("%0d")(power)));
  scale4x = d3.scale.linear().domain([0, 1]).range(xrange[2]);
  x = d3.range(npts).map(function(i) {
    return scale4x(i / npts);
  });
  data = [];
  maxalty = maxaltx = 0;
  for (j in x) {
    y = dnct(x[j], df, ncp);
    data.push({
      x: x[j],
      y: y
    });
    if (y > maxalty) {
      maxalty = y;
      maxaltx = x[j];
    }
  }
  figs[2].append("path").attr("class", "curves").datum(data).attr("d", curve(2)).attr("fill", "none").attr("stroke", colors[0]).attr("stroke-width", 2);
  if (critval < xrange[2][1]) {
    scale4x = d3.scale.linear().domain([0, 1]).range([critval, xrange[2][1]]);
    x = d3.range(npts).map(function(i) {
      return scale4x(i / npts);
    });
    data = [];
    for (j in x) {
      data.push({
        x: x[j],
        y: dnct(x[j], df, ncp)
      });
    }
    data.push({
      x: xrange[2][1],
      y: 0
    });
    data.push({
      x: critval,
      y: 0
    });
    figs[2].append("path").attr("class", "curves").datum(data).attr("d", curve(2)).attr("fill", colors[1]).attr("stroke", "none").attr("opacity", opacity);
  }
  figs[2].append("text").attr("class", "curves").text("null").attr("dominant-baseline", "middle").attr("text-anchor", "end").attr("x", xscale[2](-0.9)).attr("y", yscale[2](dt(-0.7, df)));
  if (maxalty > 0.001) {
    return figs[2].append("text").attr("class", "curves").text("alternative").attr("dominant-baseline", "middle").attr("text-anchor", function() {
      if (maxaltx > 5) {
        return "end";
      }
      return "start";
    }).attr("x", function() {
      x = maxaltx > 5 ? maxaltx - 0.8 : maxaltx + 0.8;
      return xscale[2](x);
    }).attr("y", yscale[2](dt(-0.7, df)));
  } else {
    return figs[2].append("text").attr("class", "curves").html("alternative &rarr;").attr("dominant-baseline", "middle").attr("text-anchor", "end").attr("x", function() {
      return xscale[2](7.9);
    }).attr("y", yscale[2](dt(-0.7, df)));
  }
};

update_plots();
