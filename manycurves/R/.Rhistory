rank <- as.numeric(rank[2,])
ks <- ksGenescore(nrow(fData(dat)), rank, do.plot = F)
ks.list <- rbind(ks.list, ks$statistic)
p.list <- rbind(p.list, ks$p.value)
}
ks <- ksGenescore(nrow(fData(dat)), rank, do.plot = F, bare = T)
ksGenescore(nrow(fData(dat)), rank, do.plot = F, bare = T)
KShall$ks.score <- ks.list
KShall$p.value <- p.list
rownames(KShall)<-names(hall)
## prepare a properly formatted n-by-3 data.frame, where n is the number of genesets
KShall <-
data.frame(ks.score=rep(NA,length(hall)),
p.value=NA,
q.value=NA,
row.names=names(hall))
## test the 50 hallmark genesets against the gene ranking
ks.list <- c()
p.list <- c()
pdf( "~/KShall.pdf" )
dat <- g1vsg3[,!is.na(pData(g1vsg3)[,"grade"])]
for (i in 1:50) {
geneIDX <- match(hall[[i]], toupper(rownames(tst)))
rank <- data.frame(rbind(hall[[i]], geneIDX))
rank <- rank[,colSums(is.na(rank)) < 1]
rank <- as.numeric(rank[2,])
ksGenescore(nrow(fData(dat)), rank, do.plot = F, bare = T)
ks <- ksGenescore(nrow(fData(dat)), rank, do.plot = F)
ks.list <- rbind(ks.list, ks$statistic)
p.list <- rbind(p.list, ks$p.value)
}
KShall$ks.score <- ks.list
KShall$p.value <- p.list
rownames(KShall)<-names(hall)
dev.off()
ksGenescore(nrow(fData(dat)), rank, do.plot = F, bare = T)
for (i in 1:50) {
geneIDX <- match(hall[[i]], toupper(rownames(tst)))
rank <- data.frame(rbind(hall[[i]], geneIDX))
rank <- rank[,colSums(is.na(rank)) < 1]
rank <- as.numeric(rank[2,])
ksGenescore(nrow(fData(dat)), rank, do.plot = F, bare = T)
ks <- ksGenescore(nrow(fData(dat)), rank, do.plot = F)
ks.list <- rbind(ks.list, ks$statistic)
p.list <- rbind(p.list, ks$p.value)
}
KShall$q.value <- p.adjust(KShall$p.value,method="BH")
print(head(KShall))
View(KShall)
KShall$q.value <- p.adjust(KShall$p.value,method="BH")
print(head(KShall))
print(head(KShall))
KShall$q.value <- p.adjust(KShall$p.value,method="BH")
print(head(KShall))
KShall$q.value <- p.adjust(KShall$p.value,method="BH")
print(head(KShall))
KShall$q.value <- p.adjust(KShall$p.value,method="BH")
print(head(KShall))
KShall$q.value <- p.adjust(KShall$p.value,method="BH")
print(head(KShall))
KShall$q.value <- p.adjust(KShall$p.value,method="BH")
head(KShall)
head(KShall)
head(KShall)
head(KShall)
KShall$q.value <- p.adjust(KShall$p.value,method="BH")
head(KShall)
KShall$q.value <- p.adjust(KShall$p.value,method="BH")
head(KShall)
KShall$q.value <- p.adjust(KShall$p.value,method="BH")
head(KShall)
KShall$q.value <- p.adjust(KShall$p.value,method="BH")
head(KShall)
KShall$q.value <- p.adjust(KShall$p.value,method="BH")
head(KShall)
table(pData(g1vsg3)[,"grade"])
g1 <- exprs(g1vsg3)[,g1vsg3$grade=="g1"]
g3 <- exprs(g1vsg3)[,g1vsg3$grade=="g3"]
tst <- t(sapply(1:nrow(g1),
function(i){
res <- t.test(x = g1[i, ], y = g3[i,], alternative ="two.sided")
res.list <- c(t.score = res$statistic, t.pvalue = res$p.value)
return(res.list)
}))
rownames(tst) <- make.names(fData(g1vsg3)$hgnc_symbol, unique=TRUE)
genesSorted <- toupper(fData(g1vsg3)[order(tst), "hgnc_symbol"])
head(genesSorted)
## prepare a properly formatted n-by-3 data.frame, where n is the number of genesets
KShall <-
data.frame(ks.score=rep(NA,length(hall)),
p.value=NA,
q.value=NA,
row.names=names(hall))
## test the 50 hallmark genesets against the gene ranking
dat <- g1vsg3[,!is.na(pData(g1vsg3)[,"grade"])]
for (i in 1:50) {
geneIDX <- match(hall[[i]], toupper(rownames(tst)))
rank <- data.frame(rbind(hall[[i]], geneIDX))
rank <- rank[,colSums(is.na(rank)) < 1]
rank <- as.numeric(rank[2,])
ks <- ksGenescore(nrow(fData(dat)), rank, do.plot = F)
KShall[i, 1] <- ks$statistic
KShall[i, 2] <- ks$p.value
}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE)
library(Biobase)
library(BS831)
OMPATH <- Sys.getenv("DATAPATH")
if ( OMPATH=="" ) stop( "OMPATH must be set" )
print(OMPATH)
table(pData(g1vsg3)[,"grade"])
g1 <- exprs(g1vsg3)[,g1vsg3$grade=="g1"]
g3 <- exprs(g1vsg3)[,g1vsg3$grade=="g3"]
tst <- t(sapply(1:nrow(g1),
function(i){
res <- t.test(x = g1[i, ], y = g3[i,], alternative ="two.sided")
res.list <- c(t.score = res$statistic, t.pvalue = res$p.value)
return(res.list)
}))
rownames(tst) <- make.names(fData(g1vsg3)$hgnc_symbol, unique=TRUE)
genesSorted <- toupper(fData(g1vsg3)[order(tst), "hgnc_symbol"])
head(genesSorted)
## prepare a properly formatted n-by-3 data.frame, where n is the number of genesets
KShall <-
data.frame(ks.score=rep(NA,length(hall)),
p.value=NA,
q.value=NA,
row.names=names(hall))
## test the 50 hallmark genesets against the gene ranking
dat <- g1vsg3[,!is.na(pData(g1vsg3)[,"grade"])]
for (i in 1:50) {
geneIDX <- match(hall[[i]], toupper(rownames(tst)))
rank <- data.frame(rbind(hall[[i]], geneIDX))
rank <- rank[,colSums(is.na(rank)) < 1]
rank <- as.numeric(rank[2,])
ks <- ksGenescore(nrow(fData(dat)), rank, do.plot = F)
KShall[i, 1] <- ks$statistic
KShall[i, 2] <- ks$p.value
}
rownames(KShall) <-names(hall)
KShall$q.value <- p.adjust(KShall$p.value,method="BH")
head(KShall)
## remember how you can use ks.test to test the difference btw two distributions
st1 <- shapiro.test( exprs(CPM2)[1,])
print(st1)
ST <- sapply(1:nrow(exprs(CPM2)), function(i) {
shapiro.test(exprs(CPM2[i,]))
})
colnames(ST) <- rownames(CPM2)
ST <- data.frame(t(ST[1:2,]))
ST$statistic <- as.numeric(ST$statistic)
ST$p.value <- as.numeric(ST$p.value)
ST$q.value <- p.adjust(ST$p.value, method = "BH")
head(ST)
## performing variation filtering in log space ..
CPM3 <- BS831::variationFilter(CPM2,ngenes=2000, do.plot=FALSE)
## clustering (choose the proper distances for the two dimensions – see slides)
hc.col <- hclust(dist(t(exprs(CPM2))),method="ward.D")
hc.row <- hclust(as.dist(exprs(CPM2)),method="ward.D")
## clustering (choose the proper distances for the two dimensions – see slides)
hc.col <- hclust(dist(t(exprs(CPM2))),method="ward.D")
# hc.row <- hclust(as.dist(t(exprs(CPM2))),method="ward.D")
hc.row <- hclust(as.dist(1-cor(exprs(CPM2))), method="ward.D" )
library(pheatmap)
## expression levels color coding
bwrPalette <- colGradient(c("blue","white","red"),length=13)
## sample annotation color coding
annot <- pData(CPM3)[,c("grade","stage")]
annotCol <- list(
grade = c("white","green","darkgreen"),
stage = c("white","green","darkgreen")
)
names(annotCol$grade) <- levels(annot$grade)
names(annotCol$stage) <- levels(annot$stage)
## heatmap visualization
pheatmap(exprs(CPM3),
color=bwrPalette,
annotation_col = annot,
annotation_colors = annotCol,
cluster_rows=hc.row, # the result of the hclust call above
cluster_cols=hc.col, # ditto
show_rownames = FALSE,
show_colnames = FALSE,
scale = "row")
levels(annot$stage)
# hc.row <- hclust(as.dist(t(exprs(CPM2))),method="ward.D")
hc.row <- hclust(as.dist(1-cor(t(exprs(CPM2)))), method="ward.D" )
library(pheatmap)
## expression levels color coding
bwrPalette <- colGradient(c("blue","white","red"),length=13)
## sample annotation color coding
annot <- pData(CPM3)[,c("grade","stage")]
annotCol <- list(
grade = c("white","green","darkgreen"),
stage = c("white","green","darkgreen")
)
names(annotCol$grade) <- levels(annot$grade)
names(annotCol$stage) <- levels(annot$stage)
## heatmap visualization
pheatmap(exprs(CPM3),
color=bwrPalette,
annotation_col = annot,
annotation_colors = annotCol,
cluster_rows=hc.row, # the result of the hclust call above
cluster_cols=hc.col, # ditto
show_rownames = FALSE,
show_colnames = FALSE,
scale = "row")
## clustering (choose the proper distances for the two dimensions – see slides)
hc.col <- hclust(dist(t(exprs(CPM2))),method="ward.D")
# hc.row <- hclust(as.dist(t(exprs(CPM2))),method="ward.D")
hc.row <- hclust(as.dist(1-cor(exprs(CPM2))), method="ward.D" )
library(pheatmap)
## expression levels color coding
bwrPalette <- colGradient(c("blue","white","red"),length=13)
## sample annotation color coding
annot <- pData(CPM3)[,c("grade","stage")]
annotCol <- list(
grade = c("white","green","darkgreen"),
stage = c("white","green","darkgreen")
)
names(annotCol$grade) <- levels(annot$grade)
names(annotCol$stage) <- levels(annot$stage)
## heatmap visualization
pheatmap(exprs(CPM3),
color=bwrPalette,
annotation_col = annot,
annotation_colors = annotCol,
cluster_rows=hc.row, # the result of the hclust call above
cluster_cols=hc.col, # ditto
show_rownames = FALSE,
show_colnames = FALSE,
scale = "row")
C3 <- cutree(hc.col,3)
## add cluster annotation to heatmap annotation
annot1 <- annot
annotCol1 <- annotCol
annot1$cluster <- factor(C3)
annotCol1$cluster <- c("yellow","orange","purple")
names(annotCol1$cluster) <- levels(annot1$cluster)
pheatmap(exprs(CPM3),
color=bwrPalette,
annotation_col = annot1,
annotation_colors = annotCol1,
cluster_rows=hc.row,
cluster_cols=hc.col,
show_rownames = FALSE,
show_colnames = FALSE,
scale = "row")
library(pheatmap)
## expression levels color coding
bwrPalette <- colGradient(c("blue","white","red"),length=13)
## sample annotation color coding
annot <- pData(CPM3)[,c("grade","stage")]
annotCol <- list(
grade = c("white","green","darkgreen"),
stage = c("white","green","darkgreen")
)
names(annotCol$grade) <- levels(annot$grade)
names(annotCol$stage) <- levels(annot$stage)
## heatmap visualization
pheatmap(exprs(CPM3),
color=bwrPalette,
annotation_col = annot,
annotation_colors = annotCol,
cluster_rows=hc.row, # the result of the hclust call above
cluster_cols=hc.col, # ditto
show_rownames = FALSE,
show_colnames = FALSE,
scale = "row")
C3 <- cutree(hc.col,3)
## add cluster annotation to heatmap annotation
annot1 <- annot
annotCol1 <- annotCol
annot1$cluster <- factor(C3)
annotCol1$cluster <- c("yellow","orange","purple")
names(annotCol1$cluster) <- levels(annot1$cluster)
pheatmap(exprs(CPM3),
color=bwrPalette,
annotation_col = annot1,
annotation_colors = annotCol1,
cluster_rows=hc.row,
cluster_cols=hc.col,
show_rownames = FALSE,
show_colnames = FALSE,
scale = "row")
print(table(C3,CPM3$grade))
?t.textt
?t.test
## let us log-transform the CPM data for subsequent handling
CPM2 <- CPM1
exprs(CPM2) <- log2(exprs(CPM1)+1)
## show distribution before and after log2-transformation
par(mfrow=c(1,2))
hist(exprs(CPM1),main = "Before log2-transformation")
hist(exprs(CPM2), main = "After log2-transformation" )
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE)
library(Biobase)
library(BS831)
OMPATH <- Sys.getenv("DATAPATH")
if ( OMPATH=="" ) stop( "OMPATH must be set" )
print(OMPATH)
## read CPM data
CPM <- readRDS( file.path(OMPATH,"HNSC_htseq_normalized_AEvsG1vsG3.RDS") )
## show the distribution of 'grades'
table(CPM$grade)
## let us log-transform the CPM data for subsequent handling
CPM2 <- CPM1
exprs(CPM2) <- log2(exprs(CPM1)+1)
## show distribution before and after log2-transformation
par(mfrow=c(1,2))
hist(exprs(CPM1),main = "Before log2-transformation")
hist(exprs(CPM2), main = "After log2-transformation" )
KShall$q.value <- p.adjust(KShall$p.value,method="BH")
head(KShall)
## clustering (choose the proper distances for the two dimensions – see slides)
hc.col <- hclust(dist(t(exprs(CPM2))),method="ward.D")
# hc.row <- hclust(as.dist(t(exprs(CPM2))),method="ward.D")
hc.row <- hclust(as.dist(1-cor(exprs(CPM2))), method="ward.D" )
## clustering (choose the proper distances for the two dimensions – see slides)
hc.col <- hclust(dist(t(exprs(CPM3))),method="ward.D")
# hc.row <- hclust(as.dist(t(exprs(CPM2))),method="ward.D")
hc.row <- hclust(as.dist(1-cor(exprs(CPM3))), method="ward.D" )
library(pheatmap)
## expression levels color coding
bwrPalette <- colGradient(c("blue","white","red"),length=13)
## sample annotation color coding
annot <- pData(CPM3)[,c("grade","stage")]
annotCol <- list(
grade = c("white","green","darkgreen"),
stage = c("white","green","darkgreen")
)
names(annotCol$grade) <- levels(annot$grade)
names(annotCol$stage) <- levels(annot$stage)
## heatmap visualization
pheatmap(exprs(CPM3),
color=bwrPalette,
annotation_col = annot,
annotation_colors = annotCol,
cluster_rows=hc.row, # the result of the hclust call above
cluster_cols=hc.col, # ditto
show_rownames = FALSE,
show_colnames = FALSE,
scale = "row")
C3 <- cutree(hc.col,3)
## add cluster annotation to heatmap annotation
annot1 <- annot
annotCol1 <- annotCol
annot1$cluster <- factor(C3)
annotCol1$cluster <- c("yellow","orange","purple")
names(annotCol1$cluster) <- levels(annot1$cluster)
pheatmap(exprs(CPM3),
color=bwrPalette,
annotation_col = annot1,
annotation_colors = annotCol1,
cluster_rows=hc.row,
cluster_cols=hc.col,
show_rownames = FALSE,
show_colnames = FALSE,
scale = "row")
print(table(C3,CPM3$grade))
print(table(C3,CPM3$stage))
fisher.test(C3, CPM3$stage)
C3 <- cutree(hc.col,3)
## add cluster annotation to heatmap annotation
annot1 <- annot
annotCol1 <- annotCol
annot1$cluster <- factor(C3)
annotCol1$cluster <- c("yellow","orange","purple")
names(annotCol1$cluster) <- levels(annot1$cluster)
pheatmap(exprs(CPM3),
color=bwrPalette,
annotation_col = annot1,
annotation_colors = annotCol1,
cluster_rows=hc.row,
cluster_cols=hc.col,
show_rownames = FALSE,
show_colnames = FALSE,
scale = "row")
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE)
library(Biobase)
library(BS831)
OMPATH <- Sys.getenv("DATAPATH")
if ( OMPATH=="" ) stop( "OMPATH must be set" )
print(OMPATH)
## let us log-transform the CPM data for subsequent handling
CPM2 <- CPM1
exprs(CPM2) <- log2(exprs(CPM1)+1)
## show distribution before and after log2-transformation
par(mfrow=c(1,2))
hist(exprs(CPM1),main = "Before log2-transformation")
hist(exprs(CPM2), main = "After log2-transformation" )
## performing variation filtering in log space ..
CPM3 <- BS831::variationFilter(CPM2,ngenes=2000, do.plot=FALSE)
## clustering (choose the proper distances for the two dimensions – see slides)
hc.col <- hclust(dist(t(exprs(CPM3))),method="ward.D")
# hc.row <- hclust(as.dist(t(exprs(CPM2))),method="ward.D")
hc.row <- hclust(as.dist(1-cor(exprs(CPM3))), method="ward.D" )
library(pheatmap)
## expression levels color coding
bwrPalette <- colGradient(c("blue","white","red"),length=13)
## sample annotation color coding
annot <- pData(CPM3)[,c("grade","stage")]
annotCol <- list(
grade = c("white","green","darkgreen"),
stage = c("white","green","darkgreen")
)
names(annotCol$grade) <- levels(annot$grade)
names(annotCol$stage) <- levels(annot$stage)
## heatmap visualization
pheatmap(exprs(CPM3),
color=bwrPalette,
annotation_col = annot,
annotation_colors = annotCol,
cluster_rows=hc.row, # the result of the hclust call above
cluster_cols=hc.col, # ditto
show_rownames = FALSE,
show_colnames = FALSE,
scale = "row")
C3 <- cutree(hc.col,3)
## add cluster annotation to heatmap annotation
annot1 <- annot
annotCol1 <- annotCol
annot1$cluster <- factor(C3)
annotCol1$cluster <- c("yellow","orange","purple")
names(annotCol1$cluster) <- levels(annot1$cluster)
pheatmap(exprs(CPM3),
color=bwrPalette,
annotation_col = annot1,
annotation_colors = annotCol1,
cluster_rows=hc.row,
cluster_cols=hc.col,
show_rownames = FALSE,
show_colnames = FALSE,
scale = "row")
print(table(C3,CPM3$grade))
print(table(C3,CPM3$stage))
fisher.test(C3, CPM3$stage)
fisher.test(C3, CPM3$stage)
print(table(C3,CPM3$stage))
fisher.test(C3, CPM3$stage)
require(cba) # the package implementing the optimal ordering
hc.colp <- hcopt(dist(t(exprs(CPM3))),method="ward.D")
# hc.rowp <- hcopt(dist(t(exprs(CPM2))),method="ward.D")
hc.rowp <- hcopt(as.dist(1-cor(exprs(CPM3))), method="ward.D")
hclust.pairs <- cbind(hc.col$order[-ncol(CPM3)],hc.col$order[-1])
hclust.dist <- apply(hclust.pairs,1,function(X) dist(t(exprs(CPM3)[,X])))
hcopt.pairs <- cbind(hc.colp$order[-ncol(CPM3)],hc.colp$order[-1])
hcopt.dist <- apply(hcopt.pairs,1,function(X) dist(t(exprs(CPM3)[,X])))
DIST <- data.frame(hclust=sort(hclust.dist),
hcopt=sort(hcopt.dist))
print(head(DIST))
plot(DIST$hclust, DIST$hcopt, xlab = 'sorted hclust distances', ylab = 'sorted hcopt distances')
abline(a=0, b=1, col="red")
CPM4 <- CPM3[,CPM3$grade!="AE"]
CPM4$grade <- droplevels(CPM4$grade)
CPM4$stage <- droplevels(CPM4$stage)
print(table(CPM4$grade,CPM4$stage))
?trainControl
# TODO: Finish random forest
grouplo <- exprs(CPM)[,CPM$stage=='stage.lo']
grouphi <- exprs(CPM)[,CPM$stage=='stage.hi']
DM1 <- g1vsg3[,!is.na(pData(g1vsg3)[,"grade"])]
table(droplevels(pData(DM1)[,"grade"]))
group1<-exprs(DM1)[,DM1$grade=="g1"]
group2<-exprs(DM1)[,DM1$grade=="g3"]
DM1000 <- variationFilter(DM1,ngenes=1000,score="mad",do.plot=FALSE)
DM1000$GRADE <- factor(DM1000$grade)
DM1000$STAGE <- factor(DM1000$stage)
discovery <- data.frame(t(Biobase::exprs(DM1000)))
discoveryLab <- factor(discovery$grade, levels = c("g1", "g3"))
validation <- data.frame(t(Biobase::exprs(DM1000)))
validationLab <- factor(validation, levels = c("g1", "g3"))
library(caret)
fitControl <- trainControl(method="cv",
number=10,
classProbs=T,
summaryFunction=twoClassSummary)
print(fitControl)
set.seed(1234)
library(caret)
set.seed(1234)
fitControl <- trainControl(method="cv",
number=10,
classProbs=T,
summaryFunction=twoClassSummary)
library(randomForest)
RF1 <- train(x=discovery,
y=discoveryLab,
method="rf",
trControl=fitControl,
tuneGrid=expand.grid(mtry=c(20, 50, 100, 500)),
metric='ROC')
install.packages(c("devtools", "roxygen2","usethis", "testthat"))
# save the curves matrix as a JSON file
load("curves.RData")
setwd("/home/elkip/Workspace/d3examples/manycurves/R")
# save the curves matrix as a JSON file
load("curves.RData")
nam <- colnames(curves)
times <- as.numeric(substr(nam, 5, nchar(nam))) # time in minutes (480 min = 8 hrs)
dimnames(curves) <- NULL
library(RJSONIO)
library(jsonlite)
cat0 <- function(file, ...) cat(..., sep="", file=file)
cat0a <- function(file, ...) cat(..., sep="", file=file, append=TRUE)
file <- "../curves.json"
cat0(file, "{\n")
cat0a(file, "\"times\" : \n", toJSON(times), ",\n\n")
cat0a(file, "\"curves\" : \n", toJSON(curves), "\n\n")
cat0a(file, "}\n")
write_json(curves, file)
